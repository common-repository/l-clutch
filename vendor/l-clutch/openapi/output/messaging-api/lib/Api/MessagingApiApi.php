<?php
/**
 * MessagingApiApi
 * PHP version 7.4
 *
 * @category Class
 * @package  LClutch\LineApi\MessagingApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * LINE Messaging API
 *
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace LClutch\LineApi\MessagingApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LClutch\LineApi\MessagingApi\ApiException;
use LClutch\LineApi\MessagingApi\Configuration;
use LClutch\LineApi\MessagingApi\HeaderSelector;
use LClutch\LineApi\MessagingApi\ObjectSerializer;

/**
 * MessagingApiApi Class Doc Comment
 *
 * @category Class
 * @package  LClutch\LineApi\MessagingApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MessagingApiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'audienceMatch' => [
            'application/json',
        ],
        'broadcast' => [
            'application/json',
        ],
        'cancelDefaultRichMenu' => [
            'application/json',
        ],
        'createRichMenu' => [
            'application/json',
        ],
        'createRichMenuAlias' => [
            'application/json',
        ],
        'deleteRichMenu' => [
            'application/json',
        ],
        'deleteRichMenuAlias' => [
            'application/json',
        ],
        'getAdPhoneMessageStatistics' => [
            'application/json',
        ],
        'getAggregationUnitNameList' => [
            'application/json',
        ],
        'getAggregationUnitUsage' => [
            'application/json',
        ],
        'getBotInfo' => [
            'application/json',
        ],
        'getDefaultRichMenuId' => [
            'application/json',
        ],
        'getFollowers' => [
            'application/json',
        ],
        'getGroupMemberCount' => [
            'application/json',
        ],
        'getGroupMemberProfile' => [
            'application/json',
        ],
        'getGroupMembersIds' => [
            'application/json',
        ],
        'getGroupSummary' => [
            'application/json',
        ],
        'getMessageQuota' => [
            'application/json',
        ],
        'getMessageQuotaConsumption' => [
            'application/json',
        ],
        'getNarrowcastProgress' => [
            'application/json',
        ],
        'getNumberOfSentBroadcastMessages' => [
            'application/json',
        ],
        'getNumberOfSentMulticastMessages' => [
            'application/json',
        ],
        'getNumberOfSentPushMessages' => [
            'application/json',
        ],
        'getNumberOfSentReplyMessages' => [
            'application/json',
        ],
        'getPNPMessageStatistics' => [
            'application/json',
        ],
        'getProfile' => [
            'application/json',
        ],
        'getRichMenu' => [
            'application/json',
        ],
        'getRichMenuAlias' => [
            'application/json',
        ],
        'getRichMenuAliasList' => [
            'application/json',
        ],
        'getRichMenuBatchProgress' => [
            'application/json',
        ],
        'getRichMenuIdOfUser' => [
            'application/json',
        ],
        'getRichMenuList' => [
            'application/json',
        ],
        'getRoomMemberCount' => [
            'application/json',
        ],
        'getRoomMemberProfile' => [
            'application/json',
        ],
        'getRoomMembersIds' => [
            'application/json',
        ],
        'getWebhookEndpoint' => [
            'application/json',
        ],
        'issueLinkToken' => [
            'application/json',
        ],
        'leaveGroup' => [
            'application/json',
        ],
        'leaveRoom' => [
            'application/json',
        ],
        'linkRichMenuIdToUser' => [
            'application/json',
        ],
        'linkRichMenuIdToUsers' => [
            'application/json',
        ],
        'markMessagesAsRead' => [
            'application/json',
        ],
        'multicast' => [
            'application/json',
        ],
        'narrowcast' => [
            'application/json',
        ],
        'pushMessage' => [
            'application/json',
        ],
        'pushMessagesByPhone' => [
            'application/json',
        ],
        'replyMessage' => [
            'application/json',
        ],
        'richMenuBatch' => [
            'application/json',
        ],
        'setDefaultRichMenu' => [
            'application/json',
        ],
        'setWebhookEndpoint' => [
            'application/json',
        ],
        'testWebhookEndpoint' => [
            'application/json',
        ],
        'unlinkRichMenuIdFromUser' => [
            'application/json',
        ],
        'unlinkRichMenuIdFromUsers' => [
            'application/json',
        ],
        'updateRichMenuAlias' => [
            'application/json',
        ],
        'validateBroadcast' => [
            'application/json',
        ],
        'validateMulticast' => [
            'application/json',
        ],
        'validateNarrowcast' => [
            'application/json',
        ],
        'validatePush' => [
            'application/json',
        ],
        'validateReply' => [
            'application/json',
        ],
        'validateRichMenuBatchRequest' => [
            'application/json',
        ],
        'validateRichMenuObject' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation audienceMatch
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\AudienceMatchMessagesRequest $audience_match_messages_request audience_match_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function audienceMatch($audience_match_messages_request, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $this->audienceMatchWithHttpInfo($audience_match_messages_request, $contentType);
    }

    /**
     * Operation audienceMatchWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\AudienceMatchMessagesRequest $audience_match_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function audienceMatchWithHttpInfo($audience_match_messages_request, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $request = $this->audienceMatchRequest($audience_match_messages_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation audienceMatchAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\AudienceMatchMessagesRequest $audience_match_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audienceMatchAsync($audience_match_messages_request, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        return $this->audienceMatchAsyncWithHttpInfo($audience_match_messages_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation audienceMatchAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\AudienceMatchMessagesRequest $audience_match_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audienceMatchAsyncWithHttpInfo($audience_match_messages_request, string $contentType = self::contentTypes['audienceMatch'][0])
    {
        $returnType = '';
        $request = $this->audienceMatchRequest($audience_match_messages_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'audienceMatch'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\AudienceMatchMessagesRequest $audience_match_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['audienceMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function audienceMatchRequest($audience_match_messages_request, string $contentType = self::contentTypes['audienceMatch'][0])
    {

        // verify the required parameter 'audience_match_messages_request' is set
        if ($audience_match_messages_request === null || (is_array($audience_match_messages_request) && count($audience_match_messages_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_match_messages_request when calling audienceMatch'
            );
        }


        $resourcePath = '/bot/ad/multicast/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($audience_match_messages_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($audience_match_messages_request));
            } else {
                $httpBody = $audience_match_messages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation broadcast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\BroadcastRequest $broadcast_request broadcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse
     */
    public function broadcast($broadcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        list($response) = $this->broadcastWithHttpInfo($broadcast_request, $x_line_retry_key, $contentType);
        return $response;
    }

    /**
     * Operation broadcastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\BroadcastRequest $broadcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function broadcastWithHttpInfo($broadcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        $request = $this->broadcastRequest($broadcast_request, $x_line_retry_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation broadcastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\BroadcastRequest $broadcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastAsync($broadcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        return $this->broadcastAsyncWithHttpInfo($broadcast_request, $x_line_retry_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation broadcastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\BroadcastRequest $broadcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function broadcastAsyncWithHttpInfo($broadcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['broadcast'][0])
    {
        $returnType = 'object';
        $request = $this->broadcastRequest($broadcast_request, $x_line_retry_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'broadcast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\BroadcastRequest $broadcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['broadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function broadcastRequest($broadcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['broadcast'][0])
    {

        // verify the required parameter 'broadcast_request' is set
        if ($broadcast_request === null || (is_array($broadcast_request) && count($broadcast_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $broadcast_request when calling broadcast'
            );
        }



        $resourcePath = '/v2/bot/message/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_line_retry_key !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($x_line_retry_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($broadcast_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($broadcast_request));
            } else {
                $httpBody = $broadcast_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelDefaultRichMenu
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelDefaultRichMenu(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $this->cancelDefaultRichMenuWithHttpInfo($contentType);
    }

    /**
     * Operation cancelDefaultRichMenuWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelDefaultRichMenuWithHttpInfo(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $request = $this->cancelDefaultRichMenuRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelDefaultRichMenuAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDefaultRichMenuAsync(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        return $this->cancelDefaultRichMenuAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelDefaultRichMenuAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelDefaultRichMenuAsyncWithHttpInfo(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {
        $returnType = '';
        $request = $this->cancelDefaultRichMenuRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelDefaultRichMenu'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelDefaultRichMenuRequest(string $contentType = self::contentTypes['cancelDefaultRichMenu'][0])
    {


        $resourcePath = '/v2/bot/user/all/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRichMenu
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse
     */
    public function createRichMenu($rich_menu_request, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        list($response) = $this->createRichMenuWithHttpInfo($rich_menu_request, $contentType);
        return $response;
    }

    /**
     * Operation createRichMenuWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRichMenuWithHttpInfo($rich_menu_request, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        $request = $this->createRichMenuRequest($rich_menu_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRichMenuAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAsync($rich_menu_request, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        return $this->createRichMenuAsyncWithHttpInfo($rich_menu_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRichMenuAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAsyncWithHttpInfo($rich_menu_request, string $contentType = self::contentTypes['createRichMenu'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->createRichMenuRequest($rich_menu_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRichMenu'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRichMenuRequest($rich_menu_request, string $contentType = self::contentTypes['createRichMenu'][0])
    {

        // verify the required parameter 'rich_menu_request' is set
        if ($rich_menu_request === null || (is_array($rich_menu_request) && count($rich_menu_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_request when calling createRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_request));
            } else {
                $httpBody = $rich_menu_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRichMenuAlias
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\CreateRichMenuAliasRequest $create_rich_menu_alias_request create_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createRichMenuAlias($create_rich_menu_alias_request, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $this->createRichMenuAliasWithHttpInfo($create_rich_menu_alias_request, $contentType);
    }

    /**
     * Operation createRichMenuAliasWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\CreateRichMenuAliasRequest $create_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRichMenuAliasWithHttpInfo($create_rich_menu_alias_request, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $request = $this->createRichMenuAliasRequest($create_rich_menu_alias_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRichMenuAliasAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\CreateRichMenuAliasRequest $create_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAliasAsync($create_rich_menu_alias_request, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        return $this->createRichMenuAliasAsyncWithHttpInfo($create_rich_menu_alias_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRichMenuAliasAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\CreateRichMenuAliasRequest $create_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRichMenuAliasAsyncWithHttpInfo($create_rich_menu_alias_request, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->createRichMenuAliasRequest($create_rich_menu_alias_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRichMenuAlias'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\CreateRichMenuAliasRequest $create_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRichMenuAliasRequest($create_rich_menu_alias_request, string $contentType = self::contentTypes['createRichMenuAlias'][0])
    {

        // verify the required parameter 'create_rich_menu_alias_request' is set
        if ($create_rich_menu_alias_request === null || (is_array($create_rich_menu_alias_request) && count($create_rich_menu_alias_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_rich_menu_alias_request when calling createRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_rich_menu_alias_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_rich_menu_alias_request));
            } else {
                $httpBody = $create_rich_menu_alias_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRichMenu
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRichMenu($rich_menu_id, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $this->deleteRichMenuWithHttpInfo($rich_menu_id, $contentType);
    }

    /**
     * Operation deleteRichMenuWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRichMenuWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $request = $this->deleteRichMenuRequest($rich_menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRichMenuAsync
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAsync($rich_menu_id, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        return $this->deleteRichMenuAsyncWithHttpInfo($rich_menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRichMenuAsyncWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAsyncWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {
        $returnType = '';
        $request = $this->deleteRichMenuRequest($rich_menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRichMenu'
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRichMenuRequest($rich_menu_id, string $contentType = self::contentTypes['deleteRichMenu'][0])
    {

        // verify the required parameter 'rich_menu_id' is set
        if ($rich_menu_id === null || (is_array($rich_menu_id) && count($rich_menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_id when calling deleteRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($rich_menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRichMenuAlias
     *
     * @param  string $rich_menu_alias_id Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRichMenuAlias($rich_menu_alias_id, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $this->deleteRichMenuAliasWithHttpInfo($rich_menu_alias_id, $contentType);
    }

    /**
     * Operation deleteRichMenuAliasWithHttpInfo
     *
     * @param  string $rich_menu_alias_id Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRichMenuAliasWithHttpInfo($rich_menu_alias_id, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $request = $this->deleteRichMenuAliasRequest($rich_menu_alias_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRichMenuAliasAsync
     *
     * @param  string $rich_menu_alias_id Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAliasAsync($rich_menu_alias_id, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        return $this->deleteRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $rich_menu_alias_id Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->deleteRichMenuAliasRequest($rich_menu_alias_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRichMenuAlias'
     *
     * @param  string $rich_menu_alias_id Rich menu alias ID that you want to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRichMenuAliasRequest($rich_menu_alias_id, string $contentType = self::contentTypes['deleteRichMenuAlias'][0])
    {

        // verify the required parameter 'rich_menu_alias_id' is set
        if ($rich_menu_alias_id === null || (is_array($rich_menu_alias_id) && count($rich_menu_alias_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_alias_id when calling deleteRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_alias_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($rich_menu_alias_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdPhoneMessageStatistics
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getAdPhoneMessageStatistics($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        list($response) = $this->getAdPhoneMessageStatisticsWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getAdPhoneMessageStatisticsWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdPhoneMessageStatisticsWithHttpInfo($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        $request = $this->getAdPhoneMessageStatisticsRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdPhoneMessageStatisticsAsync
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdPhoneMessageStatisticsAsync($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        return $this->getAdPhoneMessageStatisticsAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdPhoneMessageStatisticsAsyncWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdPhoneMessageStatisticsAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getAdPhoneMessageStatisticsRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdPhoneMessageStatistics'
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20190831&#x60;) Time Zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdPhoneMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAdPhoneMessageStatisticsRequest($date, string $contentType = self::contentTypes['getAdPhoneMessageStatistics'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getAdPhoneMessageStatistics'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/ad_phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregationUnitNameList
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse
     */
    public function getAggregationUnitNameList($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        list($response) = $this->getAggregationUnitNameListWithHttpInfo($limit, $start, $contentType);
        return $response;
    }

    /**
     * Operation getAggregationUnitNameListWithHttpInfo
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregationUnitNameListWithHttpInfo($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        $request = $this->getAggregationUnitNameListRequest($limit, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregationUnitNameListAsync
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitNameListAsync($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        return $this->getAggregationUnitNameListAsyncWithHttpInfo($limit, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregationUnitNameListAsyncWithHttpInfo
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitNameListAsyncWithHttpInfo($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitNameListResponse';
        $request = $this->getAggregationUnitNameListRequest($limit, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregationUnitNameList'
     *
     * @param  string $limit The maximum number of aggregation units you can get per request. (optional)
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. If you can&#39;t get all the aggregation units in one request, include this parameter to get the remaining array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitNameList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAggregationUnitNameListRequest($limit = null, $start = null, string $contentType = self::contentTypes['getAggregationUnitNameList'][0])
    {




        $resourcePath = '/v2/bot/message/aggregation/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregationUnitUsage
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse
     */
    public function getAggregationUnitUsage(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        list($response) = $this->getAggregationUnitUsageWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAggregationUnitUsageWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregationUnitUsageWithHttpInfo(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        $request = $this->getAggregationUnitUsageRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregationUnitUsageAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitUsageAsync(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        return $this->getAggregationUnitUsageAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregationUnitUsageAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregationUnitUsageAsyncWithHttpInfo(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GetAggregationUnitUsageResponse';
        $request = $this->getAggregationUnitUsageRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregationUnitUsage'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAggregationUnitUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAggregationUnitUsageRequest(string $contentType = self::contentTypes['getAggregationUnitUsage'][0])
    {


        $resourcePath = '/v2/bot/message/aggregation/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBotInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\BotInfoResponse
     */
    public function getBotInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        list($response) = $this->getBotInfoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBotInfoWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\BotInfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBotInfoWithHttpInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        $request = $this->getBotInfoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\BotInfoResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\BotInfoResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\BotInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\BotInfoResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\BotInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBotInfoAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBotInfoAsync(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        return $this->getBotInfoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBotInfoAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBotInfoAsyncWithHttpInfo(string $contentType = self::contentTypes['getBotInfo'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\BotInfoResponse';
        $request = $this->getBotInfoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBotInfo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBotInfoRequest(string $contentType = self::contentTypes['getBotInfo'][0])
    {


        $resourcePath = '/v2/bot/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDefaultRichMenuId
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse
     */
    public function getDefaultRichMenuId(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        list($response) = $this->getDefaultRichMenuIdWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getDefaultRichMenuIdWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDefaultRichMenuIdWithHttpInfo(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        $request = $this->getDefaultRichMenuIdRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDefaultRichMenuIdAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultRichMenuIdAsync(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        return $this->getDefaultRichMenuIdAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDefaultRichMenuIdAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultRichMenuIdAsyncWithHttpInfo(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->getDefaultRichMenuIdRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDefaultRichMenuId'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultRichMenuId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDefaultRichMenuIdRequest(string $contentType = self::contentTypes['getDefaultRichMenuId'][0])
    {


        $resourcePath = '/v2/bot/user/all/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFollowers
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GetFollowersResponse
     */
    public function getFollowers($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        list($response) = $this->getFollowersWithHttpInfo($start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation getFollowersWithHttpInfo
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GetFollowersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFollowersWithHttpInfo($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        $request = $this->getFollowersRequest($start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFollowersAsync
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFollowersAsync($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        return $this->getFollowersAsyncWithHttpInfo($start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFollowersAsyncWithHttpInfo
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFollowersAsyncWithHttpInfo($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GetFollowersResponse';
        $request = $this->getFollowersRequest($start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFollowers'
     *
     * @param  string $start Value of the continuation token found in the next property of the JSON object returned in the response. Include this parameter to get the next array of user IDs. (optional)
     * @param  int $limit The maximum number of user IDs to retrieve in a single request. (optional, default to 300)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFollowersRequest($start = null, $limit = 300, string $contentType = self::contentTypes['getFollowers'][0])
    {


        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling MessagingApiApi.getFollowers, must be smaller than or equal to 1000.');
        }
        

        $resourcePath = '/v2/bot/followers/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMemberCount
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse
     */
    public function getGroupMemberCount($group_id, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        list($response) = $this->getGroupMemberCountWithHttpInfo($group_id, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMemberCountWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMemberCountWithHttpInfo($group_id, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        $request = $this->getGroupMemberCountRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMemberCountAsync
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberCountAsync($group_id, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        return $this->getGroupMemberCountAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMemberCountAsyncWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberCountAsyncWithHttpInfo($group_id, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupMemberCountResponse';
        $request = $this->getGroupMemberCountRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMemberCount'
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMemberCountRequest($group_id, string $contentType = self::contentTypes['getGroupMemberCount'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupMemberCount'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/members/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMemberProfile
     *
     * @param  string $group_id Group ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse
     */
    public function getGroupMemberProfile($group_id, $user_id, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        list($response) = $this->getGroupMemberProfileWithHttpInfo($group_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMemberProfileWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMemberProfileWithHttpInfo($group_id, $user_id, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        $request = $this->getGroupMemberProfileRequest($group_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMemberProfileAsync
     *
     * @param  string $group_id Group ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberProfileAsync($group_id, $user_id, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        return $this->getGroupMemberProfileAsyncWithHttpInfo($group_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMemberProfileAsyncWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMemberProfileAsyncWithHttpInfo($group_id, $user_id, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupUserProfileResponse';
        $request = $this->getGroupMemberProfileRequest($group_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMemberProfile'
     *
     * @param  string $group_id Group ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMemberProfileRequest($group_id, $user_id, string $contentType = self::contentTypes['getGroupMemberProfile'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupMemberProfile'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getGroupMemberProfile'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/member/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupMembersIds
     *
     * @param  string $group_id Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\MembersIdsResponse
     */
    public function getGroupMembersIds($group_id, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        list($response) = $this->getGroupMembersIdsWithHttpInfo($group_id, $start, $contentType);
        return $response;
    }

    /**
     * Operation getGroupMembersIdsWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\MembersIdsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupMembersIdsWithHttpInfo($group_id, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        $request = $this->getGroupMembersIdsRequest($group_id, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupMembersIdsAsync
     *
     * @param  string $group_id Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersIdsAsync($group_id, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        return $this->getGroupMembersIdsAsyncWithHttpInfo($group_id, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupMembersIdsAsyncWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupMembersIdsAsyncWithHttpInfo($group_id, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse';
        $request = $this->getGroupMembersIdsRequest($group_id, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupMembersIds'
     *
     * @param  string $group_id Group ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupMembersIdsRequest($group_id, $start = null, string $contentType = self::contentTypes['getGroupMembersIds'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupMembersIds'
            );
        }



        $resourcePath = '/v2/bot/group/{groupId}/members/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupSummary
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse
     */
    public function getGroupSummary($group_id, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        list($response) = $this->getGroupSummaryWithHttpInfo($group_id, $contentType);
        return $response;
    }

    /**
     * Operation getGroupSummaryWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupSummaryWithHttpInfo($group_id, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        $request = $this->getGroupSummaryRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupSummaryAsync
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSummaryAsync($group_id, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        return $this->getGroupSummaryAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupSummaryAsyncWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSummaryAsyncWithHttpInfo($group_id, string $contentType = self::contentTypes['getGroupSummary'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GroupSummaryResponse';
        $request = $this->getGroupSummaryRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupSummary'
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupSummaryRequest($group_id, string $contentType = self::contentTypes['getGroupSummary'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupSummary'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageQuota
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse
     */
    public function getMessageQuota(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        list($response) = $this->getMessageQuotaWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMessageQuotaWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageQuotaWithHttpInfo(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        $request = $this->getMessageQuotaRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageQuotaAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaAsync(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        return $this->getMessageQuotaAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageQuotaAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaAsyncWithHttpInfo(string $contentType = self::contentTypes['getMessageQuota'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\MessageQuotaResponse';
        $request = $this->getMessageQuotaRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageQuota'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuota'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageQuotaRequest(string $contentType = self::contentTypes['getMessageQuota'][0])
    {


        $resourcePath = '/v2/bot/message/quota';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessageQuotaConsumption
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse
     */
    public function getMessageQuotaConsumption(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        list($response) = $this->getMessageQuotaConsumptionWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMessageQuotaConsumptionWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageQuotaConsumptionWithHttpInfo(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        $request = $this->getMessageQuotaConsumptionRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageQuotaConsumptionAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaConsumptionAsync(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        return $this->getMessageQuotaConsumptionAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageQuotaConsumptionAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMessageQuotaConsumptionAsyncWithHttpInfo(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\QuotaConsumptionResponse';
        $request = $this->getMessageQuotaConsumptionRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessageQuotaConsumption'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessageQuotaConsumption'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageQuotaConsumptionRequest(string $contentType = self::contentTypes['getMessageQuotaConsumption'][0])
    {


        $resourcePath = '/v2/bot/message/quota/consumption';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNarrowcastProgress
     *
     * @param  string $request_id The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse
     */
    public function getNarrowcastProgress($request_id, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        list($response) = $this->getNarrowcastProgressWithHttpInfo($request_id, $contentType);
        return $response;
    }

    /**
     * Operation getNarrowcastProgressWithHttpInfo
     *
     * @param  string $request_id The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNarrowcastProgressWithHttpInfo($request_id, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        $request = $this->getNarrowcastProgressRequest($request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNarrowcastProgressAsync
     *
     * @param  string $request_id The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNarrowcastProgressAsync($request_id, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        return $this->getNarrowcastProgressAsyncWithHttpInfo($request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNarrowcastProgressAsyncWithHttpInfo
     *
     * @param  string $request_id The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNarrowcastProgressAsyncWithHttpInfo($request_id, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NarrowcastProgressResponse';
        $request = $this->getNarrowcastProgressRequest($request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNarrowcastProgress'
     *
     * @param  string $request_id The narrowcast message&#39;s request ID. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNarrowcastProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNarrowcastProgressRequest($request_id, string $contentType = self::contentTypes['getNarrowcastProgress'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getNarrowcastProgress'
            );
        }


        $resourcePath = '/v2/bot/message/progress/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $request_id,
            'requestId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentBroadcastMessages
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentBroadcastMessages($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        list($response) = $this->getNumberOfSentBroadcastMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentBroadcastMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        $request = $this->getNumberOfSentBroadcastMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentBroadcastMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        return $this->getNumberOfSentBroadcastMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentBroadcastMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentBroadcastMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentBroadcastMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentBroadcastMessages'
     *
     * @param  string $date Date the messages were sent  Format: yyyyMMdd (e.g. 20191231) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentBroadcastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentBroadcastMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentBroadcastMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentBroadcastMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentMulticastMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentMulticastMessages($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        list($response) = $this->getNumberOfSentMulticastMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentMulticastMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentMulticastMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        $request = $this->getNumberOfSentMulticastMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentMulticastMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentMulticastMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        return $this->getNumberOfSentMulticastMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentMulticastMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentMulticastMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentMulticastMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentMulticastMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentMulticastMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentMulticastMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentMulticastMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentMulticastMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentPushMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentPushMessages($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        list($response) = $this->getNumberOfSentPushMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentPushMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentPushMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        $request = $this->getNumberOfSentPushMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentPushMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentPushMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        return $this->getNumberOfSentPushMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentPushMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentPushMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentPushMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentPushMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentPushMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentPushMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentPushMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentPushMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNumberOfSentReplyMessages
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getNumberOfSentReplyMessages($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        list($response) = $this->getNumberOfSentReplyMessagesWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getNumberOfSentReplyMessagesWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNumberOfSentReplyMessagesWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        $request = $this->getNumberOfSentReplyMessagesRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNumberOfSentReplyMessagesAsync
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentReplyMessagesAsync($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        return $this->getNumberOfSentReplyMessagesAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNumberOfSentReplyMessagesAsyncWithHttpInfo
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNumberOfSentReplyMessagesAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getNumberOfSentReplyMessagesRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNumberOfSentReplyMessages'
     *
     * @param  string $date Date the messages were sent  Format: &#x60;yyyyMMdd&#x60; (e.g. &#x60;20191231&#x60;) Timezone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNumberOfSentReplyMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNumberOfSentReplyMessagesRequest($date, string $contentType = self::contentTypes['getNumberOfSentReplyMessages'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getNumberOfSentReplyMessages'
            );
        }


        $resourcePath = '/v2/bot/message/delivery/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPNPMessageStatistics
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse
     */
    public function getPNPMessageStatistics($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        list($response) = $this->getPNPMessageStatisticsWithHttpInfo($date, $contentType);
        return $response;
    }

    /**
     * Operation getPNPMessageStatisticsWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPNPMessageStatisticsWithHttpInfo($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        $request = $this->getPNPMessageStatisticsRequest($date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPNPMessageStatisticsAsync
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPNPMessageStatisticsAsync($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        return $this->getPNPMessageStatisticsAsyncWithHttpInfo($date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPNPMessageStatisticsAsyncWithHttpInfo
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPNPMessageStatisticsAsyncWithHttpInfo($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\NumberOfMessagesResponse';
        $request = $this->getPNPMessageStatisticsRequest($date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPNPMessageStatistics'
     *
     * @param  string $date Date the message was sent  Format: &#x60;yyyyMMdd&#x60; (Example:&#x60;20211231&#x60;) Time zone: UTC+9 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPNPMessageStatistics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPNPMessageStatisticsRequest($date, string $contentType = self::contentTypes['getPNPMessageStatistics'][0])
    {

        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling getPNPMessageStatistics'
            );
        }
        if (!preg_match("/^[0-9]{8}$/", $date)) {
            throw new \InvalidArgumentException("invalid value for \"date\" when calling MessagingApiApi.getPNPMessageStatistics, must conform to the pattern /^[0-9]{8}$/.");
        }
        

        $resourcePath = '/v2/bot/message/delivery/pnp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProfile
     *
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\UserProfileResponse
     */
    public function getProfile($user_id, string $contentType = self::contentTypes['getProfile'][0])
    {
        list($response) = $this->getProfileWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation getProfileWithHttpInfo
     *
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\UserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProfileWithHttpInfo($user_id, string $contentType = self::contentTypes['getProfile'][0])
    {
        $request = $this->getProfileRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\UserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\UserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\UserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\UserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\UserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProfileAsync
     *
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsync($user_id, string $contentType = self::contentTypes['getProfile'][0])
    {
        return $this->getProfileAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProfileAsyncWithHttpInfo
     *
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProfileAsyncWithHttpInfo($user_id, string $contentType = self::contentTypes['getProfile'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\UserProfileResponse';
        $request = $this->getProfileRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProfile'
     *
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProfileRequest($user_id, string $contentType = self::contentTypes['getProfile'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getProfile'
            );
        }


        $resourcePath = '/v2/bot/profile/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenu
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuResponse
     */
    public function getRichMenu($rich_menu_id, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        list($response) = $this->getRichMenuWithHttpInfo($rich_menu_id, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        $request = $this->getRichMenuRequest($rich_menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAsync
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAsync($rich_menu_id, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        return $this->getRichMenuAsyncWithHttpInfo($rich_menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAsyncWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAsyncWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['getRichMenu'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuResponse';
        $request = $this->getRichMenuRequest($rich_menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenu'
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuRequest($rich_menu_id, string $contentType = self::contentTypes['getRichMenu'][0])
    {

        // verify the required parameter 'rich_menu_id' is set
        if ($rich_menu_id === null || (is_array($rich_menu_id) && count($rich_menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_id when calling getRichMenu'
            );
        }


        $resourcePath = '/v2/bot/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($rich_menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuAlias
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse
     */
    public function getRichMenuAlias($rich_menu_alias_id, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        list($response) = $this->getRichMenuAliasWithHttpInfo($rich_menu_alias_id, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuAliasWithHttpInfo
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuAliasWithHttpInfo($rich_menu_alias_id, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        $request = $this->getRichMenuAliasRequest($rich_menu_alias_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAliasAsync
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasAsync($rich_menu_alias_id, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        return $this->getRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasResponse';
        $request = $this->getRichMenuAliasRequest($rich_menu_alias_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuAlias'
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID whose information you want to obtain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuAliasRequest($rich_menu_alias_id, string $contentType = self::contentTypes['getRichMenuAlias'][0])
    {

        // verify the required parameter 'rich_menu_alias_id' is set
        if ($rich_menu_alias_id === null || (is_array($rich_menu_alias_id) && count($rich_menu_alias_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_alias_id when calling getRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_alias_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($rich_menu_alias_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuAliasList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse
     */
    public function getRichMenuAliasList(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        list($response) = $this->getRichMenuAliasListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRichMenuAliasListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuAliasListWithHttpInfo(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        $request = $this->getRichMenuAliasListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuAliasListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasListAsync(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        return $this->getRichMenuAliasListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuAliasListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuAliasListAsyncWithHttpInfo(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuAliasListResponse';
        $request = $this->getRichMenuAliasListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuAliasList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuAliasList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuAliasListRequest(string $contentType = self::contentTypes['getRichMenuAliasList'][0])
    {


        $resourcePath = '/v2/bot/richmenu/alias/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuBatchProgress
     *
     * @param  string $request_id A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse
     */
    public function getRichMenuBatchProgress($request_id, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        list($response) = $this->getRichMenuBatchProgressWithHttpInfo($request_id, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuBatchProgressWithHttpInfo
     *
     * @param  string $request_id A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuBatchProgressWithHttpInfo($request_id, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        $request = $this->getRichMenuBatchProgressRequest($request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuBatchProgressAsync
     *
     * @param  string $request_id A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuBatchProgressAsync($request_id, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        return $this->getRichMenuBatchProgressAsyncWithHttpInfo($request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuBatchProgressAsyncWithHttpInfo
     *
     * @param  string $request_id A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuBatchProgressAsyncWithHttpInfo($request_id, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuBatchProgressResponse';
        $request = $this->getRichMenuBatchProgressRequest($request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuBatchProgress'
     *
     * @param  string $request_id A request ID used to batch control the rich menu linked to the user. Each Messaging API request has a request ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuBatchProgress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuBatchProgressRequest($request_id, string $contentType = self::contentTypes['getRichMenuBatchProgress'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getRichMenuBatchProgress'
            );
        }


        $resourcePath = '/v2/bot/richmenu/progress/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $request_id,
            'requestId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuIdOfUser
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse
     */
    public function getRichMenuIdOfUser($user_id, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        list($response) = $this->getRichMenuIdOfUserWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation getRichMenuIdOfUserWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuIdOfUserWithHttpInfo($user_id, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        $request = $this->getRichMenuIdOfUserRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuIdOfUserAsync
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuIdOfUserAsync($user_id, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        return $this->getRichMenuIdOfUserAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuIdOfUserAsyncWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuIdOfUserAsyncWithHttpInfo($user_id, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuIdResponse';
        $request = $this->getRichMenuIdOfUserRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuIdOfUser'
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuIdOfUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuIdOfUserRequest($user_id, string $contentType = self::contentTypes['getRichMenuIdOfUser'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getRichMenuIdOfUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRichMenuList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RichMenuListResponse
     */
    public function getRichMenuList(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        list($response) = $this->getRichMenuListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRichMenuListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RichMenuListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRichMenuListWithHttpInfo(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        $request = $this->getRichMenuListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRichMenuListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuListAsync(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        return $this->getRichMenuListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRichMenuListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRichMenuListAsyncWithHttpInfo(string $contentType = self::contentTypes['getRichMenuList'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RichMenuListResponse';
        $request = $this->getRichMenuListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRichMenuList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRichMenuList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRichMenuListRequest(string $contentType = self::contentTypes['getRichMenuList'][0])
    {


        $resourcePath = '/v2/bot/richmenu/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMemberCount
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse
     */
    public function getRoomMemberCount($room_id, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        list($response) = $this->getRoomMemberCountWithHttpInfo($room_id, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMemberCountWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMemberCountWithHttpInfo($room_id, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        $request = $this->getRoomMemberCountRequest($room_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMemberCountAsync
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberCountAsync($room_id, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        return $this->getRoomMemberCountAsyncWithHttpInfo($room_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMemberCountAsyncWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberCountAsyncWithHttpInfo($room_id, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RoomMemberCountResponse';
        $request = $this->getRoomMemberCountRequest($room_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMemberCount'
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMemberCountRequest($room_id, string $contentType = self::contentTypes['getRoomMemberCount'][0])
    {

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getRoomMemberCount'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/members/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMemberProfile
     *
     * @param  string $room_id Room ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse
     */
    public function getRoomMemberProfile($room_id, $user_id, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        list($response) = $this->getRoomMemberProfileWithHttpInfo($room_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMemberProfileWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMemberProfileWithHttpInfo($room_id, $user_id, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        $request = $this->getRoomMemberProfileRequest($room_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMemberProfileAsync
     *
     * @param  string $room_id Room ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberProfileAsync($room_id, $user_id, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        return $this->getRoomMemberProfileAsyncWithHttpInfo($room_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMemberProfileAsyncWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMemberProfileAsyncWithHttpInfo($room_id, $user_id, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\RoomUserProfileResponse';
        $request = $this->getRoomMemberProfileRequest($room_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMemberProfile'
     *
     * @param  string $room_id Room ID (required)
     * @param  string $user_id User ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMemberProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMemberProfileRequest($room_id, $user_id, string $contentType = self::contentTypes['getRoomMemberProfile'][0])
    {

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getRoomMemberProfile'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getRoomMemberProfile'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/member/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomMembersIds
     *
     * @param  string $room_id Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\MembersIdsResponse
     */
    public function getRoomMembersIds($room_id, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        list($response) = $this->getRoomMembersIdsWithHttpInfo($room_id, $start, $contentType);
        return $response;
    }

    /**
     * Operation getRoomMembersIdsWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\MembersIdsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomMembersIdsWithHttpInfo($room_id, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        $request = $this->getRoomMembersIdsRequest($room_id, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoomMembersIdsAsync
     *
     * @param  string $room_id Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMembersIdsAsync($room_id, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        return $this->getRoomMembersIdsAsyncWithHttpInfo($room_id, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomMembersIdsAsyncWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomMembersIdsAsyncWithHttpInfo($room_id, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\MembersIdsResponse';
        $request = $this->getRoomMembersIdsRequest($room_id, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomMembersIds'
     *
     * @param  string $room_id Room ID (required)
     * @param  string $start Value of the continuation token found in the &#x60;next&#x60; property of the JSON object returned in the response. Include this parameter to get the next array of user IDs for the members of the group. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomMembersIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomMembersIdsRequest($room_id, $start = null, string $contentType = self::contentTypes['getRoomMembersIds'][0])
    {

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getRoomMembersIds'
            );
        }



        $resourcePath = '/v2/bot/room/{roomId}/members/ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookEndpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse
     */
    public function getWebhookEndpoint(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        list($response) = $this->getWebhookEndpointWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getWebhookEndpointWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookEndpointWithHttpInfo(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        $request = $this->getWebhookEndpointRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookEndpointAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookEndpointAsync(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        return $this->getWebhookEndpointAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookEndpointAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookEndpointAsyncWithHttpInfo(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\GetWebhookEndpointResponse';
        $request = $this->getWebhookEndpointRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookEndpoint'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookEndpointRequest(string $contentType = self::contentTypes['getWebhookEndpoint'][0])
    {


        $resourcePath = '/v2/bot/channel/webhook/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueLinkToken
     *
     * @param  string $user_id User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse
     */
    public function issueLinkToken($user_id, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        list($response) = $this->issueLinkTokenWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation issueLinkTokenWithHttpInfo
     *
     * @param  string $user_id User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueLinkTokenWithHttpInfo($user_id, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        $request = $this->issueLinkTokenRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueLinkTokenAsync
     *
     * @param  string $user_id User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueLinkTokenAsync($user_id, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        return $this->issueLinkTokenAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueLinkTokenAsyncWithHttpInfo
     *
     * @param  string $user_id User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueLinkTokenAsyncWithHttpInfo($user_id, string $contentType = self::contentTypes['issueLinkToken'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\IssueLinkTokenResponse';
        $request = $this->issueLinkTokenRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueLinkToken'
     *
     * @param  string $user_id User ID for the LINE account to be linked. Found in the &#x60;source&#x60; object of account link event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['issueLinkToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueLinkTokenRequest($user_id, string $contentType = self::contentTypes['issueLinkToken'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling issueLinkToken'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/linkToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveGroup
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function leaveGroup($group_id, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $this->leaveGroupWithHttpInfo($group_id, $contentType);
    }

    /**
     * Operation leaveGroupWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveGroupWithHttpInfo($group_id, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $request = $this->leaveGroupRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveGroupAsync
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveGroupAsync($group_id, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        return $this->leaveGroupAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveGroupAsyncWithHttpInfo
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveGroupAsyncWithHttpInfo($group_id, string $contentType = self::contentTypes['leaveGroup'][0])
    {
        $returnType = '';
        $request = $this->leaveGroupRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveGroup'
     *
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveGroupRequest($group_id, string $contentType = self::contentTypes['leaveGroup'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling leaveGroup'
            );
        }


        $resourcePath = '/v2/bot/group/{groupId}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveRoom
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function leaveRoom($room_id, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $this->leaveRoomWithHttpInfo($room_id, $contentType);
    }

    /**
     * Operation leaveRoomWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveRoomWithHttpInfo($room_id, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $request = $this->leaveRoomRequest($room_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation leaveRoomAsync
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveRoomAsync($room_id, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        return $this->leaveRoomAsyncWithHttpInfo($room_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveRoomAsyncWithHttpInfo
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveRoomAsyncWithHttpInfo($room_id, string $contentType = self::contentTypes['leaveRoom'][0])
    {
        $returnType = '';
        $request = $this->leaveRoomRequest($room_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveRoom'
     *
     * @param  string $room_id Room ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveRoomRequest($room_id, string $contentType = self::contentTypes['leaveRoom'][0])
    {

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling leaveRoom'
            );
        }


        $resourcePath = '/v2/bot/room/{roomId}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roomId' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation linkRichMenuIdToUser
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function linkRichMenuIdToUser($user_id, $rich_menu_id, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $this->linkRichMenuIdToUserWithHttpInfo($user_id, $rich_menu_id, $contentType);
    }

    /**
     * Operation linkRichMenuIdToUserWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function linkRichMenuIdToUserWithHttpInfo($user_id, $rich_menu_id, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $request = $this->linkRichMenuIdToUserRequest($user_id, $rich_menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation linkRichMenuIdToUserAsync
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUserAsync($user_id, $rich_menu_id, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        return $this->linkRichMenuIdToUserAsyncWithHttpInfo($user_id, $rich_menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation linkRichMenuIdToUserAsyncWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUserAsyncWithHttpInfo($user_id, $rich_menu_id, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {
        $returnType = '';
        $request = $this->linkRichMenuIdToUserRequest($user_id, $rich_menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'linkRichMenuIdToUser'
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function linkRichMenuIdToUserRequest($user_id, $rich_menu_id, string $contentType = self::contentTypes['linkRichMenuIdToUser'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling linkRichMenuIdToUser'
            );
        }

        // verify the required parameter 'rich_menu_id' is set
        if ($rich_menu_id === null || (is_array($rich_menu_id) && count($rich_menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_id when calling linkRichMenuIdToUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($rich_menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($rich_menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation linkRichMenuIdToUsers
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkLinkRequest $rich_menu_bulk_link_request rich_menu_bulk_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function linkRichMenuIdToUsers($rich_menu_bulk_link_request, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $this->linkRichMenuIdToUsersWithHttpInfo($rich_menu_bulk_link_request, $contentType);
    }

    /**
     * Operation linkRichMenuIdToUsersWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkLinkRequest $rich_menu_bulk_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function linkRichMenuIdToUsersWithHttpInfo($rich_menu_bulk_link_request, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $request = $this->linkRichMenuIdToUsersRequest($rich_menu_bulk_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation linkRichMenuIdToUsersAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkLinkRequest $rich_menu_bulk_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUsersAsync($rich_menu_bulk_link_request, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        return $this->linkRichMenuIdToUsersAsyncWithHttpInfo($rich_menu_bulk_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation linkRichMenuIdToUsersAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkLinkRequest $rich_menu_bulk_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkRichMenuIdToUsersAsyncWithHttpInfo($rich_menu_bulk_link_request, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {
        $returnType = '';
        $request = $this->linkRichMenuIdToUsersRequest($rich_menu_bulk_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'linkRichMenuIdToUsers'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkLinkRequest $rich_menu_bulk_link_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['linkRichMenuIdToUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function linkRichMenuIdToUsersRequest($rich_menu_bulk_link_request, string $contentType = self::contentTypes['linkRichMenuIdToUsers'][0])
    {

        // verify the required parameter 'rich_menu_bulk_link_request' is set
        if ($rich_menu_bulk_link_request === null || (is_array($rich_menu_bulk_link_request) && count($rich_menu_bulk_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_bulk_link_request when calling linkRichMenuIdToUsers'
            );
        }


        $resourcePath = '/v2/bot/richmenu/bulk/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_bulk_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_bulk_link_request));
            } else {
                $httpBody = $rich_menu_bulk_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markMessagesAsRead
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MarkMessagesAsReadRequest $mark_messages_as_read_request mark_messages_as_read_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function markMessagesAsRead($mark_messages_as_read_request, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $this->markMessagesAsReadWithHttpInfo($mark_messages_as_read_request, $contentType);
    }

    /**
     * Operation markMessagesAsReadWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MarkMessagesAsReadRequest $mark_messages_as_read_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markMessagesAsReadWithHttpInfo($mark_messages_as_read_request, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $request = $this->markMessagesAsReadRequest($mark_messages_as_read_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation markMessagesAsReadAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MarkMessagesAsReadRequest $mark_messages_as_read_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markMessagesAsReadAsync($mark_messages_as_read_request, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        return $this->markMessagesAsReadAsyncWithHttpInfo($mark_messages_as_read_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markMessagesAsReadAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MarkMessagesAsReadRequest $mark_messages_as_read_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markMessagesAsReadAsyncWithHttpInfo($mark_messages_as_read_request, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {
        $returnType = '';
        $request = $this->markMessagesAsReadRequest($mark_messages_as_read_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markMessagesAsRead'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MarkMessagesAsReadRequest $mark_messages_as_read_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markMessagesAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markMessagesAsReadRequest($mark_messages_as_read_request, string $contentType = self::contentTypes['markMessagesAsRead'][0])
    {

        // verify the required parameter 'mark_messages_as_read_request' is set
        if ($mark_messages_as_read_request === null || (is_array($mark_messages_as_read_request) && count($mark_messages_as_read_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mark_messages_as_read_request when calling markMessagesAsRead'
            );
        }


        $resourcePath = '/v2/bot/message/markAsRead';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mark_messages_as_read_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mark_messages_as_read_request));
            } else {
                $httpBody = $mark_messages_as_read_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation multicast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MulticastRequest $multicast_request multicast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse
     */
    public function multicast($multicast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['multicast'][0])
    {
        list($response) = $this->multicastWithHttpInfo($multicast_request, $x_line_retry_key, $contentType);
        return $response;
    }

    /**
     * Operation multicastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MulticastRequest $multicast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function multicastWithHttpInfo($multicast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['multicast'][0])
    {
        $request = $this->multicastRequest($multicast_request, $x_line_retry_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation multicastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MulticastRequest $multicast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function multicastAsync($multicast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['multicast'][0])
    {
        return $this->multicastAsyncWithHttpInfo($multicast_request, $x_line_retry_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation multicastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MulticastRequest $multicast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function multicastAsyncWithHttpInfo($multicast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['multicast'][0])
    {
        $returnType = 'object';
        $request = $this->multicastRequest($multicast_request, $x_line_retry_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'multicast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\MulticastRequest $multicast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['multicast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function multicastRequest($multicast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['multicast'][0])
    {

        // verify the required parameter 'multicast_request' is set
        if ($multicast_request === null || (is_array($multicast_request) && count($multicast_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $multicast_request when calling multicast'
            );
        }



        $resourcePath = '/v2/bot/message/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_line_retry_key !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($x_line_retry_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($multicast_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($multicast_request));
            } else {
                $httpBody = $multicast_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation narrowcast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\NarrowcastRequest $narrowcast_request narrowcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse
     */
    public function narrowcast($narrowcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        list($response) = $this->narrowcastWithHttpInfo($narrowcast_request, $x_line_retry_key, $contentType);
        return $response;
    }

    /**
     * Operation narrowcastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\NarrowcastRequest $narrowcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function narrowcastWithHttpInfo($narrowcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        $request = $this->narrowcastRequest($narrowcast_request, $x_line_retry_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation narrowcastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\NarrowcastRequest $narrowcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function narrowcastAsync($narrowcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        return $this->narrowcastAsyncWithHttpInfo($narrowcast_request, $x_line_retry_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation narrowcastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\NarrowcastRequest $narrowcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function narrowcastAsyncWithHttpInfo($narrowcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['narrowcast'][0])
    {
        $returnType = 'object';
        $request = $this->narrowcastRequest($narrowcast_request, $x_line_retry_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'narrowcast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\NarrowcastRequest $narrowcast_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['narrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function narrowcastRequest($narrowcast_request, $x_line_retry_key = null, string $contentType = self::contentTypes['narrowcast'][0])
    {

        // verify the required parameter 'narrowcast_request' is set
        if ($narrowcast_request === null || (is_array($narrowcast_request) && count($narrowcast_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $narrowcast_request when calling narrowcast'
            );
        }



        $resourcePath = '/v2/bot/message/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_line_retry_key !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($x_line_retry_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($narrowcast_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($narrowcast_request));
            } else {
                $httpBody = $narrowcast_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushMessage
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PushMessageRequest $push_message_request push_message_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\PushMessageResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse
     */
    public function pushMessage($push_message_request, $x_line_retry_key = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        list($response) = $this->pushMessageWithHttpInfo($push_message_request, $x_line_retry_key, $contentType);
        return $response;
    }

    /**
     * Operation pushMessageWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PushMessageRequest $push_message_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\PushMessageResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushMessageWithHttpInfo($push_message_request, $x_line_retry_key = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        $request = $this->pushMessageRequest($push_message_request, $x_line_retry_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\PushMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\PushMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\PushMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\PushMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\PushMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pushMessageAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PushMessageRequest $push_message_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessageAsync($push_message_request, $x_line_retry_key = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        return $this->pushMessageAsyncWithHttpInfo($push_message_request, $x_line_retry_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushMessageAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PushMessageRequest $push_message_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessageAsyncWithHttpInfo($push_message_request, $x_line_retry_key = null, string $contentType = self::contentTypes['pushMessage'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\PushMessageResponse';
        $request = $this->pushMessageRequest($push_message_request, $x_line_retry_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushMessage'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PushMessageRequest $push_message_request (required)
     * @param  string $x_line_retry_key Retry key. Specifies the UUID in hexadecimal format (e.g., &#x60;123e4567-e89b-12d3-a456-426614174000&#x60;) generated by any method. The retry key isn&#39;t generated by LINE. Each developer must generate their own retry key. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pushMessageRequest($push_message_request, $x_line_retry_key = null, string $contentType = self::contentTypes['pushMessage'][0])
    {

        // verify the required parameter 'push_message_request' is set
        if ($push_message_request === null || (is_array($push_message_request) && count($push_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $push_message_request when calling pushMessage'
            );
        }



        $resourcePath = '/v2/bot/message/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_line_retry_key !== null) {
            $headerParams['X-Line-Retry-Key'] = ObjectSerializer::toHeaderValue($x_line_retry_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($push_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($push_message_request));
            } else {
                $httpBody = $push_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushMessagesByPhone
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PnpMessagesRequest $pnp_messages_request pnp_messages_request (required)
     * @param  string $x_line_delivery_tag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pushMessagesByPhone($pnp_messages_request, $x_line_delivery_tag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $this->pushMessagesByPhoneWithHttpInfo($pnp_messages_request, $x_line_delivery_tag, $contentType);
    }

    /**
     * Operation pushMessagesByPhoneWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PnpMessagesRequest $pnp_messages_request (required)
     * @param  string $x_line_delivery_tag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushMessagesByPhoneWithHttpInfo($pnp_messages_request, $x_line_delivery_tag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $request = $this->pushMessagesByPhoneRequest($pnp_messages_request, $x_line_delivery_tag, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pushMessagesByPhoneAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PnpMessagesRequest $pnp_messages_request (required)
     * @param  string $x_line_delivery_tag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessagesByPhoneAsync($pnp_messages_request, $x_line_delivery_tag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        return $this->pushMessagesByPhoneAsyncWithHttpInfo($pnp_messages_request, $x_line_delivery_tag, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushMessagesByPhoneAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PnpMessagesRequest $pnp_messages_request (required)
     * @param  string $x_line_delivery_tag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushMessagesByPhoneAsyncWithHttpInfo($pnp_messages_request, $x_line_delivery_tag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {
        $returnType = '';
        $request = $this->pushMessagesByPhoneRequest($pnp_messages_request, $x_line_delivery_tag, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushMessagesByPhone'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\PnpMessagesRequest $pnp_messages_request (required)
     * @param  string $x_line_delivery_tag String returned in the delivery.data property of the delivery completion event via Webhook. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pushMessagesByPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pushMessagesByPhoneRequest($pnp_messages_request, $x_line_delivery_tag = null, string $contentType = self::contentTypes['pushMessagesByPhone'][0])
    {

        // verify the required parameter 'pnp_messages_request' is set
        if ($pnp_messages_request === null || (is_array($pnp_messages_request) && count($pnp_messages_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pnp_messages_request when calling pushMessagesByPhone'
            );
        }

        if ($x_line_delivery_tag !== null && strlen($x_line_delivery_tag) > 100) {
            throw new \InvalidArgumentException('invalid length for "$x_line_delivery_tag" when calling MessagingApiApi.pushMessagesByPhone, must be smaller than or equal to 100.');
        }
        if ($x_line_delivery_tag !== null && strlen($x_line_delivery_tag) < 16) {
            throw new \InvalidArgumentException('invalid length for "$x_line_delivery_tag" when calling MessagingApiApi.pushMessagesByPhone, must be bigger than or equal to 16.');
        }
        

        $resourcePath = '/bot/pnp/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_line_delivery_tag !== null) {
            $headerParams['X-Line-Delivery-Tag'] = ObjectSerializer::toHeaderValue($x_line_delivery_tag);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pnp_messages_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pnp_messages_request));
            } else {
                $httpBody = $pnp_messages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replyMessage
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ReplyMessageRequest $reply_message_request reply_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse
     */
    public function replyMessage($reply_message_request, string $contentType = self::contentTypes['replyMessage'][0])
    {
        list($response) = $this->replyMessageWithHttpInfo($reply_message_request, $contentType);
        return $response;
    }

    /**
     * Operation replyMessageWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ReplyMessageRequest $reply_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse|\LClutch\LineApi\MessagingApi\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function replyMessageWithHttpInfo($reply_message_request, string $contentType = self::contentTypes['replyMessage'][0])
    {
        $request = $this->replyMessageRequest($reply_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replyMessageAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ReplyMessageRequest $reply_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replyMessageAsync($reply_message_request, string $contentType = self::contentTypes['replyMessage'][0])
    {
        return $this->replyMessageAsyncWithHttpInfo($reply_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replyMessageAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ReplyMessageRequest $reply_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replyMessageAsyncWithHttpInfo($reply_message_request, string $contentType = self::contentTypes['replyMessage'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\ReplyMessageResponse';
        $request = $this->replyMessageRequest($reply_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replyMessage'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ReplyMessageRequest $reply_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replyMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replyMessageRequest($reply_message_request, string $contentType = self::contentTypes['replyMessage'][0])
    {

        // verify the required parameter 'reply_message_request' is set
        if ($reply_message_request === null || (is_array($reply_message_request) && count($reply_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reply_message_request when calling replyMessage'
            );
        }


        $resourcePath = '/v2/bot/message/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reply_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reply_message_request));
            } else {
                $httpBody = $reply_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation richMenuBatch
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function richMenuBatch($rich_menu_batch_request, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $this->richMenuBatchWithHttpInfo($rich_menu_batch_request, $contentType);
    }

    /**
     * Operation richMenuBatchWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function richMenuBatchWithHttpInfo($rich_menu_batch_request, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $request = $this->richMenuBatchRequest($rich_menu_batch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation richMenuBatchAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function richMenuBatchAsync($rich_menu_batch_request, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        return $this->richMenuBatchAsyncWithHttpInfo($rich_menu_batch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation richMenuBatchAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function richMenuBatchAsyncWithHttpInfo($rich_menu_batch_request, string $contentType = self::contentTypes['richMenuBatch'][0])
    {
        $returnType = '';
        $request = $this->richMenuBatchRequest($rich_menu_batch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'richMenuBatch'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['richMenuBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function richMenuBatchRequest($rich_menu_batch_request, string $contentType = self::contentTypes['richMenuBatch'][0])
    {

        // verify the required parameter 'rich_menu_batch_request' is set
        if ($rich_menu_batch_request === null || (is_array($rich_menu_batch_request) && count($rich_menu_batch_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_batch_request when calling richMenuBatch'
            );
        }


        $resourcePath = '/v2/bot/richmenu/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_batch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_batch_request));
            } else {
                $httpBody = $rich_menu_batch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setDefaultRichMenu
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setDefaultRichMenu($rich_menu_id, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $this->setDefaultRichMenuWithHttpInfo($rich_menu_id, $contentType);
    }

    /**
     * Operation setDefaultRichMenuWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setDefaultRichMenuWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $request = $this->setDefaultRichMenuRequest($rich_menu_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setDefaultRichMenuAsync
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDefaultRichMenuAsync($rich_menu_id, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        return $this->setDefaultRichMenuAsyncWithHttpInfo($rich_menu_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setDefaultRichMenuAsyncWithHttpInfo
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDefaultRichMenuAsyncWithHttpInfo($rich_menu_id, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {
        $returnType = '';
        $request = $this->setDefaultRichMenuRequest($rich_menu_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setDefaultRichMenu'
     *
     * @param  string $rich_menu_id ID of a rich menu (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setDefaultRichMenu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setDefaultRichMenuRequest($rich_menu_id, string $contentType = self::contentTypes['setDefaultRichMenu'][0])
    {

        // verify the required parameter 'rich_menu_id' is set
        if ($rich_menu_id === null || (is_array($rich_menu_id) && count($rich_menu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_id when calling setDefaultRichMenu'
            );
        }


        $resourcePath = '/v2/bot/user/all/richmenu/{richMenuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuId' . '}',
                ObjectSerializer::toPathValue($rich_menu_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setWebhookEndpoint
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\SetWebhookEndpointRequest $set_webhook_endpoint_request set_webhook_endpoint_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setWebhookEndpoint($set_webhook_endpoint_request, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $this->setWebhookEndpointWithHttpInfo($set_webhook_endpoint_request, $contentType);
    }

    /**
     * Operation setWebhookEndpointWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\SetWebhookEndpointRequest $set_webhook_endpoint_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setWebhookEndpointWithHttpInfo($set_webhook_endpoint_request, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $request = $this->setWebhookEndpointRequest($set_webhook_endpoint_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setWebhookEndpointAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\SetWebhookEndpointRequest $set_webhook_endpoint_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebhookEndpointAsync($set_webhook_endpoint_request, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        return $this->setWebhookEndpointAsyncWithHttpInfo($set_webhook_endpoint_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setWebhookEndpointAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\SetWebhookEndpointRequest $set_webhook_endpoint_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setWebhookEndpointAsyncWithHttpInfo($set_webhook_endpoint_request, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {
        $returnType = '';
        $request = $this->setWebhookEndpointRequest($set_webhook_endpoint_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setWebhookEndpoint'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\SetWebhookEndpointRequest $set_webhook_endpoint_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setWebhookEndpointRequest($set_webhook_endpoint_request, string $contentType = self::contentTypes['setWebhookEndpoint'][0])
    {

        // verify the required parameter 'set_webhook_endpoint_request' is set
        if ($set_webhook_endpoint_request === null || (is_array($set_webhook_endpoint_request) && count($set_webhook_endpoint_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $set_webhook_endpoint_request when calling setWebhookEndpoint'
            );
        }


        $resourcePath = '/v2/bot/channel/webhook/endpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_webhook_endpoint_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_webhook_endpoint_request));
            } else {
                $httpBody = $set_webhook_endpoint_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testWebhookEndpoint
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointRequest $test_webhook_endpoint_request test_webhook_endpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse
     */
    public function testWebhookEndpoint($test_webhook_endpoint_request = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        list($response) = $this->testWebhookEndpointWithHttpInfo($test_webhook_endpoint_request, $contentType);
        return $response;
    }

    /**
     * Operation testWebhookEndpointWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointRequest $test_webhook_endpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function testWebhookEndpointWithHttpInfo($test_webhook_endpoint_request = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        $request = $this->testWebhookEndpointRequest($test_webhook_endpoint_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testWebhookEndpointAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointRequest $test_webhook_endpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testWebhookEndpointAsync($test_webhook_endpoint_request = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        return $this->testWebhookEndpointAsyncWithHttpInfo($test_webhook_endpoint_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testWebhookEndpointAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointRequest $test_webhook_endpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testWebhookEndpointAsyncWithHttpInfo($test_webhook_endpoint_request = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {
        $returnType = '\LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointResponse';
        $request = $this->testWebhookEndpointRequest($test_webhook_endpoint_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testWebhookEndpoint'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\TestWebhookEndpointRequest $test_webhook_endpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testWebhookEndpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testWebhookEndpointRequest($test_webhook_endpoint_request = null, string $contentType = self::contentTypes['testWebhookEndpoint'][0])
    {



        $resourcePath = '/v2/bot/channel/webhook/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($test_webhook_endpoint_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($test_webhook_endpoint_request));
            } else {
                $httpBody = $test_webhook_endpoint_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkRichMenuIdFromUser
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unlinkRichMenuIdFromUser($user_id, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $this->unlinkRichMenuIdFromUserWithHttpInfo($user_id, $contentType);
    }

    /**
     * Operation unlinkRichMenuIdFromUserWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkRichMenuIdFromUserWithHttpInfo($user_id, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $request = $this->unlinkRichMenuIdFromUserRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlinkRichMenuIdFromUserAsync
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUserAsync($user_id, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        return $this->unlinkRichMenuIdFromUserAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkRichMenuIdFromUserAsyncWithHttpInfo
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUserAsyncWithHttpInfo($user_id, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {
        $returnType = '';
        $request = $this->unlinkRichMenuIdFromUserRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkRichMenuIdFromUser'
     *
     * @param  string $user_id User ID. Found in the &#x60;source&#x60; object of webhook event objects. Do not use the LINE ID used in LINE. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkRichMenuIdFromUserRequest($user_id, string $contentType = self::contentTypes['unlinkRichMenuIdFromUser'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling unlinkRichMenuIdFromUser'
            );
        }


        $resourcePath = '/v2/bot/user/{userId}/richmenu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlinkRichMenuIdFromUsers
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkUnlinkRequest $rich_menu_bulk_unlink_request rich_menu_bulk_unlink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unlinkRichMenuIdFromUsers($rich_menu_bulk_unlink_request, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $this->unlinkRichMenuIdFromUsersWithHttpInfo($rich_menu_bulk_unlink_request, $contentType);
    }

    /**
     * Operation unlinkRichMenuIdFromUsersWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkUnlinkRequest $rich_menu_bulk_unlink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlinkRichMenuIdFromUsersWithHttpInfo($rich_menu_bulk_unlink_request, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $request = $this->unlinkRichMenuIdFromUsersRequest($rich_menu_bulk_unlink_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlinkRichMenuIdFromUsersAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkUnlinkRequest $rich_menu_bulk_unlink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUsersAsync($rich_menu_bulk_unlink_request, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        return $this->unlinkRichMenuIdFromUsersAsyncWithHttpInfo($rich_menu_bulk_unlink_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlinkRichMenuIdFromUsersAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkUnlinkRequest $rich_menu_bulk_unlink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlinkRichMenuIdFromUsersAsyncWithHttpInfo($rich_menu_bulk_unlink_request, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {
        $returnType = '';
        $request = $this->unlinkRichMenuIdFromUsersRequest($rich_menu_bulk_unlink_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlinkRichMenuIdFromUsers'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBulkUnlinkRequest $rich_menu_bulk_unlink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlinkRichMenuIdFromUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlinkRichMenuIdFromUsersRequest($rich_menu_bulk_unlink_request, string $contentType = self::contentTypes['unlinkRichMenuIdFromUsers'][0])
    {

        // verify the required parameter 'rich_menu_bulk_unlink_request' is set
        if ($rich_menu_bulk_unlink_request === null || (is_array($rich_menu_bulk_unlink_request) && count($rich_menu_bulk_unlink_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_bulk_unlink_request when calling unlinkRichMenuIdFromUsers'
            );
        }


        $resourcePath = '/v2/bot/richmenu/bulk/unlink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_bulk_unlink_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_bulk_unlink_request));
            } else {
                $httpBody = $rich_menu_bulk_unlink_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRichMenuAlias
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID you want to update. (required)
     * @param  \LClutch\LineApi\MessagingApi\Model\UpdateRichMenuAliasRequest $update_rich_menu_alias_request update_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateRichMenuAlias($rich_menu_alias_id, $update_rich_menu_alias_request, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $this->updateRichMenuAliasWithHttpInfo($rich_menu_alias_id, $update_rich_menu_alias_request, $contentType);
    }

    /**
     * Operation updateRichMenuAliasWithHttpInfo
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID you want to update. (required)
     * @param  \LClutch\LineApi\MessagingApi\Model\UpdateRichMenuAliasRequest $update_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRichMenuAliasWithHttpInfo($rich_menu_alias_id, $update_rich_menu_alias_request, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $request = $this->updateRichMenuAliasRequest($rich_menu_alias_id, $update_rich_menu_alias_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LClutch\LineApi\MessagingApi\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRichMenuAliasAsync
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID you want to update. (required)
     * @param  \LClutch\LineApi\MessagingApi\Model\UpdateRichMenuAliasRequest $update_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRichMenuAliasAsync($rich_menu_alias_id, $update_rich_menu_alias_request, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        return $this->updateRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, $update_rich_menu_alias_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRichMenuAliasAsyncWithHttpInfo
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID you want to update. (required)
     * @param  \LClutch\LineApi\MessagingApi\Model\UpdateRichMenuAliasRequest $update_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRichMenuAliasAsyncWithHttpInfo($rich_menu_alias_id, $update_rich_menu_alias_request, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {
        $returnType = '';
        $request = $this->updateRichMenuAliasRequest($rich_menu_alias_id, $update_rich_menu_alias_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRichMenuAlias'
     *
     * @param  string $rich_menu_alias_id The rich menu alias ID you want to update. (required)
     * @param  \LClutch\LineApi\MessagingApi\Model\UpdateRichMenuAliasRequest $update_rich_menu_alias_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRichMenuAlias'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateRichMenuAliasRequest($rich_menu_alias_id, $update_rich_menu_alias_request, string $contentType = self::contentTypes['updateRichMenuAlias'][0])
    {

        // verify the required parameter 'rich_menu_alias_id' is set
        if ($rich_menu_alias_id === null || (is_array($rich_menu_alias_id) && count($rich_menu_alias_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_alias_id when calling updateRichMenuAlias'
            );
        }

        // verify the required parameter 'update_rich_menu_alias_request' is set
        if ($update_rich_menu_alias_request === null || (is_array($update_rich_menu_alias_request) && count($update_rich_menu_alias_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_rich_menu_alias_request when calling updateRichMenuAlias'
            );
        }


        $resourcePath = '/v2/bot/richmenu/alias/{richMenuAliasId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rich_menu_alias_id !== null) {
            $resourcePath = str_replace(
                '{' . 'richMenuAliasId' . '}',
                ObjectSerializer::toPathValue($rich_menu_alias_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_rich_menu_alias_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_rich_menu_alias_request));
            } else {
                $httpBody = $update_rich_menu_alias_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateBroadcast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateBroadcast($validate_message_request, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $this->validateBroadcastWithHttpInfo($validate_message_request, $contentType);
    }

    /**
     * Operation validateBroadcastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateBroadcastWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $request = $this->validateBroadcastRequest($validate_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateBroadcastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateBroadcastAsync($validate_message_request, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        return $this->validateBroadcastAsyncWithHttpInfo($validate_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateBroadcastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateBroadcastAsyncWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateBroadcast'][0])
    {
        $returnType = '';
        $request = $this->validateBroadcastRequest($validate_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateBroadcast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateBroadcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateBroadcastRequest($validate_message_request, string $contentType = self::contentTypes['validateBroadcast'][0])
    {

        // verify the required parameter 'validate_message_request' is set
        if ($validate_message_request === null || (is_array($validate_message_request) && count($validate_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validate_message_request when calling validateBroadcast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/broadcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_message_request));
            } else {
                $httpBody = $validate_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateMulticast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateMulticast($validate_message_request, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $this->validateMulticastWithHttpInfo($validate_message_request, $contentType);
    }

    /**
     * Operation validateMulticastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateMulticastWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $request = $this->validateMulticastRequest($validate_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateMulticastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateMulticastAsync($validate_message_request, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        return $this->validateMulticastAsyncWithHttpInfo($validate_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateMulticastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateMulticastAsyncWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateMulticast'][0])
    {
        $returnType = '';
        $request = $this->validateMulticastRequest($validate_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateMulticast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateMulticast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateMulticastRequest($validate_message_request, string $contentType = self::contentTypes['validateMulticast'][0])
    {

        // verify the required parameter 'validate_message_request' is set
        if ($validate_message_request === null || (is_array($validate_message_request) && count($validate_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validate_message_request when calling validateMulticast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/multicast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_message_request));
            } else {
                $httpBody = $validate_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateNarrowcast
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateNarrowcast($validate_message_request, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $this->validateNarrowcastWithHttpInfo($validate_message_request, $contentType);
    }

    /**
     * Operation validateNarrowcastWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateNarrowcastWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $request = $this->validateNarrowcastRequest($validate_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateNarrowcastAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateNarrowcastAsync($validate_message_request, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        return $this->validateNarrowcastAsyncWithHttpInfo($validate_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateNarrowcastAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateNarrowcastAsyncWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {
        $returnType = '';
        $request = $this->validateNarrowcastRequest($validate_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateNarrowcast'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateNarrowcast'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateNarrowcastRequest($validate_message_request, string $contentType = self::contentTypes['validateNarrowcast'][0])
    {

        // verify the required parameter 'validate_message_request' is set
        if ($validate_message_request === null || (is_array($validate_message_request) && count($validate_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validate_message_request when calling validateNarrowcast'
            );
        }


        $resourcePath = '/v2/bot/message/validate/narrowcast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_message_request));
            } else {
                $httpBody = $validate_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validatePush
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validatePush($validate_message_request, string $contentType = self::contentTypes['validatePush'][0])
    {
        $this->validatePushWithHttpInfo($validate_message_request, $contentType);
    }

    /**
     * Operation validatePushWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validatePushWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validatePush'][0])
    {
        $request = $this->validatePushRequest($validate_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validatePushAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validatePushAsync($validate_message_request, string $contentType = self::contentTypes['validatePush'][0])
    {
        return $this->validatePushAsyncWithHttpInfo($validate_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validatePushAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validatePushAsyncWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validatePush'][0])
    {
        $returnType = '';
        $request = $this->validatePushRequest($validate_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validatePush'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validatePush'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validatePushRequest($validate_message_request, string $contentType = self::contentTypes['validatePush'][0])
    {

        // verify the required parameter 'validate_message_request' is set
        if ($validate_message_request === null || (is_array($validate_message_request) && count($validate_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validate_message_request when calling validatePush'
            );
        }


        $resourcePath = '/v2/bot/message/validate/push';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_message_request));
            } else {
                $httpBody = $validate_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateReply
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateReply($validate_message_request, string $contentType = self::contentTypes['validateReply'][0])
    {
        $this->validateReplyWithHttpInfo($validate_message_request, $contentType);
    }

    /**
     * Operation validateReplyWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateReplyWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateReply'][0])
    {
        $request = $this->validateReplyRequest($validate_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateReplyAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateReplyAsync($validate_message_request, string $contentType = self::contentTypes['validateReply'][0])
    {
        return $this->validateReplyAsyncWithHttpInfo($validate_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateReplyAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateReplyAsyncWithHttpInfo($validate_message_request, string $contentType = self::contentTypes['validateReply'][0])
    {
        $returnType = '';
        $request = $this->validateReplyRequest($validate_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateReply'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\ValidateMessageRequest $validate_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateReply'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateReplyRequest($validate_message_request, string $contentType = self::contentTypes['validateReply'][0])
    {

        // verify the required parameter 'validate_message_request' is set
        if ($validate_message_request === null || (is_array($validate_message_request) && count($validate_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $validate_message_request when calling validateReply'
            );
        }


        $resourcePath = '/v2/bot/message/validate/reply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_message_request));
            } else {
                $httpBody = $validate_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateRichMenuBatchRequest
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateRichMenuBatchRequest($rich_menu_batch_request, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $this->validateRichMenuBatchRequestWithHttpInfo($rich_menu_batch_request, $contentType);
    }

    /**
     * Operation validateRichMenuBatchRequestWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateRichMenuBatchRequestWithHttpInfo($rich_menu_batch_request, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $request = $this->validateRichMenuBatchRequestRequest($rich_menu_batch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateRichMenuBatchRequestAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuBatchRequestAsync($rich_menu_batch_request, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        return $this->validateRichMenuBatchRequestAsyncWithHttpInfo($rich_menu_batch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateRichMenuBatchRequestAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuBatchRequestAsyncWithHttpInfo($rich_menu_batch_request, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {
        $returnType = '';
        $request = $this->validateRichMenuBatchRequestRequest($rich_menu_batch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateRichMenuBatchRequest'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuBatchRequest $rich_menu_batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuBatchRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateRichMenuBatchRequestRequest($rich_menu_batch_request, string $contentType = self::contentTypes['validateRichMenuBatchRequest'][0])
    {

        // verify the required parameter 'rich_menu_batch_request' is set
        if ($rich_menu_batch_request === null || (is_array($rich_menu_batch_request) && count($rich_menu_batch_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_batch_request when calling validateRichMenuBatchRequest'
            );
        }


        $resourcePath = '/v2/bot/richmenu/validate/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_batch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_batch_request));
            } else {
                $httpBody = $rich_menu_batch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateRichMenuObject
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function validateRichMenuObject($rich_menu_request, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $this->validateRichMenuObjectWithHttpInfo($rich_menu_request, $contentType);
    }

    /**
     * Operation validateRichMenuObjectWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \LClutch\LineApi\MessagingApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateRichMenuObjectWithHttpInfo($rich_menu_request, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $request = $this->validateRichMenuObjectRequest($rich_menu_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation validateRichMenuObjectAsync
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuObjectAsync($rich_menu_request, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        return $this->validateRichMenuObjectAsyncWithHttpInfo($rich_menu_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateRichMenuObjectAsyncWithHttpInfo
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateRichMenuObjectAsyncWithHttpInfo($rich_menu_request, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {
        $returnType = '';
        $request = $this->validateRichMenuObjectRequest($rich_menu_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateRichMenuObject'
     *
     * @param  \LClutch\LineApi\MessagingApi\Model\RichMenuRequest $rich_menu_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateRichMenuObject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateRichMenuObjectRequest($rich_menu_request, string $contentType = self::contentTypes['validateRichMenuObject'][0])
    {

        // verify the required parameter 'rich_menu_request' is set
        if ($rich_menu_request === null || (is_array($rich_menu_request) && count($rich_menu_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rich_menu_request when calling validateRichMenuObject'
            );
        }


        $resourcePath = '/v2/bot/richmenu/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rich_menu_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rich_menu_request));
            } else {
                $httpBody = $rich_menu_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
